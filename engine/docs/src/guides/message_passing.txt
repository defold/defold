Message passing
===============

Message passing is the mechanism used by Defold to permit objects to communicate without creating dependencies between them. In your game logic code you post messages to a message queue that the engine constantly delivers. All message dispatch is asynchronous.

[NOTE]
====
You can read more about message passing here: http://en.wikipedia.org/wiki/Message_passing

====

Consider this simple example: suppose that your game features a HUD with a set of on screen elements like stats (health, score and number of bonus stars). The HUD is controlled by a game object "hud".

image::images/message_passing/HUD.png["HUD", align="center"]

We want to be able to increase and decrease health and we do that by sending a message to the "hud" object's script component:

[source-code]
----
msg.post("hud#script", "increase_health")
----

This will post a message with the id (or name) "increase_health" to the recipient component "script" in the object "hud". Defold will deliver the message as soon as possible.

It is then up to the code assigned to the "hud" game object to respond to that message by increasing the score in a nicely presented manner.

[source-code]
----
-- file: hud.script

function on_message(self, message_id, message, sender)
	if message_id == hash("increase_health") then
		-- Let’s add one heart to the HUD with flashy animations.
		…
	end
end
----

Message data
------------

The complete signature of the +msg.post()+ call is

[source-code]
----
msg.post(receiver, message_id[, message])
----

For convenience we add a message that sets all information on the HUD in one go. We name the message "set_stats" and attach new data in the message parameter:

[source-code]
----
msg.post("hud#script", "set_stats", { score = 100, stars = 2, health = 4 })
----

The call adds a data parameter to the message recipient and message name/id. The data argument is optional and should be a Lua table, with key-value pairs inside curly braces. Almost any type of data can be included in the message Lua table. You can pass numbers, strings, booleans, URL:s and hashes (you can't, however, pass functions) -- and you can nest other tables as part of the data:

[source-code]
----
local invtable = { sword = true, shield = true, bow = true, arrows = 9 }
local msgdata = { score = 100, stars = 2, health = 4, inventory = invtable }		
msg.post("hud#script", "set_stats", msgdata)
----

on_message()
------------

The +on_message()+ function takes three parameters (apart from "self" which will contain a reference to the game object itself).

[source-code]
----
function on_message(self, message_id, message, sender)
----

+message_id+ :: Contains the name of the message. The name is hashed.
+message+ :: Contains the message data. This is a Lua table.
+sender+ :: Contains the full URL of the sender.

If we inspect the variables received in the "hud" object’s script it contains:

+message_id+ ::	hash: [set_stats]
+message+ :: {  stars = 2,  score = 100,  health = 4 }
+sender+ :: url: [default:/rulemaster#script]

The message_id and sender values might look unfamiliar. In order to properly grasp how they are used we need to look at how Defold addresses objects, but first we should look at how "hud" implements a simple version of "set_stats”:

[source-code]
----
function init(self)
        -- Duplicate GUI nodes for hearts x 10 and stars x 10
        self.heart_nodes = {}
        self.star_nodes = {}
        local heart_node = gui.get_node("heart")
        local star_node = gui.get_node("star")
        
        -- Store all nodes in a table for easy access
        table.insert(self.heart_nodes, heart_node)
        -- Start with the nodes disabled
        gui.set_enabled(heart_node, false)
        
        for i = 1, 9 do
                local clone = gui.clone(heart_node)
                local pos = gui.get_position(heart_node)
                pos.x = pos.x + i * 32
                gui.set_position(clone, pos)
                table.insert(self.heart_nodes, clone)
                gui.set_enabled(clone, false)
        end        
        table.insert(self.star_nodes, star_node)
        gui.set_enabled(star_node, false)
        for i = 1, 9 do
                local clone = gui.clone(star_node)
                local pos = gui.get_position(star_node)
                pos.x = pos.x + i * 32
                gui.set_position(clone, pos)
                table.insert(self.star_nodes, clone)
                gui.set_enabled(clone, false)
        end        
end

function on_message(self, message_id, message, sender)
        if message_id == hash("set_stats") then        
                -- Update the score GUI node
                gui.set_text(gui.get_node("score"), message.score)
                -- Enable the right number of heart nodes
                for i = 1, message.health do
                        gui.set_enabled(self.heart_nodes[i], true)
                end                
                -- Enable the right number of star nodes
                for i = 1, message.stars do
                        gui.set_enabled(self.star_nodes[i], true)
                end                                                
        end
end

----

Addressing and URLs
-------------------

Every object in Defold is uniquely addressed through a URL (Uniform Resource Locator). The address is set at compile time and stays fixed throughout  the object’s lifetime. This means that if you save the address to an object it will stay valid for as long as the object exists; you never have to worry about updating object references that you store.

=== Paths

When you organize your project, you add game objects into a hierarchy. In its simplest form it’s a set of game objects directly under the top level collection. Let’s look at an example from a hypothetical game about cards. Initially we place two game objects side by side under "main.collection", which is the top level collection that we have told Defold to load at startup.

image::images/message_passing/editor_cards.png["Cards", align="center"]

These game objects have a path referring to their place within the hierarchy. For the card characters the paths are:

        clubmaster :: "/clubmaster"
        heartson :: "/heartson"

We can also conveniently group objects into collections and place these collections inside our hierarchy. Our little card world needs some vegetation and so we have prepared a collection with a very special kind of tree in a pot.

image::images/message_passing/editor_cards_and_tree.png["Cards and tree", align="center"]

The paths for the tree and the pot are:

        tree :: "/hearttree/tree"
        pot :: "/hearttree/pot"

The pot is a separate object since we want to later be able to animate and sway the tree independently of the pot. Now, if we add a second instance of this tree collection we get new unique paths for those added objects:

image::images/message_passing/editor_cards_and_trees.png["Cards and trees", align="center"]

        tree :: "/hearttree1/tree"
        pot :: "/hearttree1/pot"

The Defold editor will automatically assign unique names when you place a collection or an object of the same type. You can change these names to whatever you like—the editor will keep track of the paths and make sure that each object is uniquely identified. If a name collision happen, the Defold editor will signal an error.

So each object’s path (or id) is set as you organize the objects in the editor—inside collections and sub-collections. You can always rely on the path to be correct since it never changes during runtime.

=== Absolute and relative paths

Recall the  message we sent to our "hud" object earlier:

[source-code]
----
msg.post("hud#script", "increase_health")
----

We see that we addressed the object without an initial front slash ('/'). A path without an initial front slash is interpreted as a relative path, meaning that it is resolved in relation to the sending object’s place in the collection hierarchy. Absolute paths are fully expressed beginning at the root (the initial front slash) of the current socket (topmost collection) and all the way through the collection hierarchy down to the object.

If we want the pot object in the hearttree collection to send a message to the tree inside the same collection, we probably want to use relative paths. But let’s first see what happens if we send the message with an absolute path to the receiver:

[source-code]
----
-- file: pot.script
msg.post("/hearttree/tree#script", "grow")
----

This message would reach the tree inside the "hearttree" collection. However, when the other pot object that we placed inside the "hearttree1" collection sends the message, it will end up at the tree inside "hearttree", not the object inside "hearttree1". (Remember that the objects inside the collection instances share their scripts too)

If we instead use a relative path everything will work perfectly:

[source-code]
----
msg.post("tree#script", "grow")
----

Now the message is sent to the object "tree" inside the current collection, no matter if it is "hearttree", "hearttree1" or some other collection or sub-collection we have created.

The path component of a URL must always be expressed as an absolute path. If we want to construct a URL ourselves, either with the +msg.url()+ function or by typing the URL in string form, we must give an absolute path. So:

[source-code]
----
msg.post("default:/hearttree/tree#script", "grow")          -- OK!
msg.post("default:tree#script", "grow")                     -- ERROR!
----

Omitting the root front slash result in an error message because there is no game object with absolute path "tree".

----
ERROR:GAMEOBJECT: Instance 'tree' could not be found when dispatching message 'grow' sent from default:/hearttree/pot#script
----

=== URLs

The sender URL is composed of three parts that tells us all we need to know about the sender of the message we’re receiving. The format of a URL is:

----
 "[socket:][path][#fragment]"
----

"." :: (a URL shorthand for the current game object)
"#" :: (a URL shorthand for the current script)

From the above example, the URL "default:/hearttree/tree#script" tells us the following:

. It comes from the collection "default" (which is the default name of our top level collection—unless we have renamed it). This part of the URL is called socket.
. "/hearttree/tree" is the id of the game object that sent us the message. This part of the URL is called path.
. "script" is the component of that game object that was responsible for sending the message. This part of the URL is called fragment.

=== Shorthands

It is also possible to express a message receiver without giving a socket or fragment. We have already seen examples where the socket was omitted:

[source-code]
----
msg.post("tree#script", "grow")
----

This will address the message to the specified object inside the current top level collection (which is our socket).

[NOTE]
====
There are some quite rare situations where you need to specifically address a socket. See <<anchor-at, Advanced topics>> below for more information.)

====

It is also valid to leave out the fragment part of the address:

[source-code]
----
msg.post("tree", "change_color")
----

If you omit the fragment (the target component) like this Defold will broadcast the message to all components in the receiver object.

== Child-parent vs. collection-object hierarchies

We have seen how object addressing via paths is static in Defold meaning that when you code your game logic you can always trust the integrity of object’s paths (id:s).

Object parent-child hierarchies is a dynamic relation affecting how objects react to transformations. Any transformation applied to an object will in turn be applied to the object’s children. You can alter an object’s parent in run-time by sending "set_parent" messages.

[source-code]
----
local parent = go.get_id("tree")
msg.post(".", "set_parent", { parent_id = parent })
----

Parent-child hierarchies can also be set up the editor, and will still be dynamic.  Let’s, for example, add "heart" objects to our "hearttrees”. The hearts will reside inside the hearttree collections but will also be children under the tree object:

image::images/message_passing/editor_heart_tree.png["Heart tree", align="center"]

By making the hearts children of the tree, they will be affected by transformations as if they were parts of the tree object: if you animate the tree to sway back and forth, the hearts will follow the animation. The pot, however, will not animate with the tree.

[IMPORTANT]
====
Note that the paths to the heart objects inside the "hearttree" collection are unaffected by the dynamic parent-child relation we set up:

. /hearttree/heart1 (_Not "/hearttree/tree/heart1"_)
. /hearttree/heart2
. /hearttree/heart3
. /hearttree/heart4

The parent-child relationship is separate from the address of the object within the collection hierarchy. Thus, the parent-child relationship is _in no way_ reflected in the URL of an object.
====

[[anchor-at]]
== Advanced topics

=== Constructing URLs

In rare situations you might find the need to build URL objects programmatically. You can do it like this:

[source-code]
----
local url = msg.url()
url.socket = "default"
url.path = hash("/hearttree/tree")
url.fragment = "script"
msg.post(url, "grow")
----

=== System sockets

Defold uses sockets for communicating with certain engine subsystems. Those are:

. +@physics:+
. +@render:+
. +@system:+

Note that all are sockets with no path nor fragment.

For instance, you can toggle the system profiler by sending a message +msg.post("@system:", "toggle_profile")+

=== Collection Proxies

When Defold starts up it will automatically load and initiate the collection specified in the "main_collection" paramenter under "bootstrap" in the game project settings.

You might want to load different collections dynamically and, for example, keep different game levels in separate collections. Defold uses a specific collection proxy object that acts as proxy for a collection that can be loaded dynamically.

Suppose that we add a collection proxy object and set it to represent some collection that we have named "level". We can then load the collection by sending a message to the proxy:

image::images/message_passing/message_passing_proxy.png["Proxy", align="center"]

[source-code]
----
msg.post("/loader#levelproxy", "load")
----

When the collection has loaded we get a message back and can initiate and start sending messages to the other top level collection:

[source-code]
----
function on_message(self, message_id, message, sender)
    if message_id == hash("proxy_loaded") then
        -- The collection has loaded and it's time to enable it.
        msg.post(sender, "enable")
        -- Send a message to someone in the loaded collection
        msg.post("level:/gamemaster#script", "wake_up")
    end
end
----

When we send message between top level collections like this, we have to use the socket field of the URL to designate the collection the target object resides in.

[NOTE]
====
A more in depth description can be found in the link:/doc/collection_proxies[Collection proxies] documentation.
====

=== Message chains

When posted messages are dispatched and the recipients’ +on_message()+ is called, it is common that you post new messages in your reaction code. You can build long chains of messaging that the engine has to dispatch. When does this happen? 

The short answer is that the dispatching happens immediately. The engine has started dispatching messages and will continue to do so until the message queue is empty—even if you continue to fill the queue by posting new messages.

There is, however, a hard limit to how many times the engine tries to empty the queue, which effectively puts a limit to how long message chains you can expect to be fully dispatched within a frame. You can easily test how many dispatch passes the engine performs between each +update()+ with the following script:

[source-code]
----
function init(self)
        -- We’re starting a long message chain during object init
        -- and keeps it running through a number of update() steps.
        print("INIT")
        msg.post("#", "msg")
        self.updates = 0
        self.count = 0
end

function update(self, dt)
        if self.updates < 5 then
                self.updates = self.updates + 1
                print("UPDATE " .. self.updates)
                print(self.count .. " dispatch passes before this update.")
                self.count = 0
        end
end

function on_message(self, message_id, message, sender)
        if message_id == hash("msg") then
                self.count = self.count + 1
                msg.post("#", "msg")
        end
end
----

Running this script will print something like the following:

----
DEBUG:SCRIPT: INIT
INFO:ENGINE: Defold Engine 1.2.36 (5b5af21)
DEBUG:SCRIPT: UPDATE 1
DEBUG:SCRIPT: 10 dispatch passes before this update.
DEBUG:SCRIPT: UPDATE 2
DEBUG:SCRIPT: 75 dispatch passes before this update.
DEBUG:SCRIPT: UPDATE 3
DEBUG:SCRIPT: 75 dispatch passes before this update.
DEBUG:SCRIPT: UPDATE 4
DEBUG:SCRIPT: 75 dispatch passes before this update.
DEBUG:SCRIPT: UPDATE 5
DEBUG:SCRIPT: 75 dispatch passes before this update.
----

We see that this particular Defold engine version performs 10 dispatch passes on the message queue between +init()+ and the first call to +update()+. It then performs 75 passes during each subsequent update loop.
