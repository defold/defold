diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/BroadphaseCollision/btDispatcher.h c/bullet-2.77/src/BulletCollision/BroadphaseCollision/btDispatcher.h
--- a/bullet-2.77/src/BulletCollision/BroadphaseCollision/btDispatcher.h	2018-07-16 11:55:29.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/BroadphaseCollision/btDispatcher.h	2018-07-16 12:04:11.000000000 +0200
@@ -48,7 +48,6 @@
 		m_allowedCcdPenetration(btScalar(0.04)),
 		m_useConvexConservativeDistanceUtil(false),
 		m_convexConservativeDistanceThreshold(0.0f),
-		m_convexMaxDistanceUseCPT(false),
 		m_stackAllocator(0)
 	{
 
@@ -65,7 +64,6 @@
 	btScalar	m_allowedCcdPenetration;
 	bool		m_useConvexConservativeDistanceUtil;
 	btScalar	m_convexConservativeDistanceThreshold;
-	bool		m_convexMaxDistanceUseCPT;
 	btStackAlloc*	m_stackAllocator;
 };
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/BroadphaseCollision/btQuantizedBvh.h c/bullet-2.77/src/BulletCollision/BroadphaseCollision/btQuantizedBvh.h
--- a/bullet-2.77/src/BulletCollision/BroadphaseCollision/btQuantizedBvh.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/BroadphaseCollision/btQuantizedBvh.h	2018-07-16 12:51:08.000000000 +0200
@@ -4,8 +4,8 @@
 
 This software is provided 'as-is', without any express or implied warranty.
 In no event will the authors be held liable for any damages arising from the use of this software.
-Permission is granted to anyone to use this software for any purpose, 
-including commercial applications, and to alter it and redistribute it freely, 
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:
 
 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
@@ -78,8 +78,10 @@
 	int	getTriangleIndex() const
 	{
 		btAssert(isLeafNode());
+		unsigned int x=0;
+		unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);
 		// Get only the lower bits where the triangle index is stored
-		return (m_escapeIndexOrTriangleIndex&~((~0)<<(31-MAX_NUM_PARTS_IN_BITS)));
+		return (m_escapeIndexOrTriangleIndex&~(y));
 	}
 	int	getPartId() const
 	{
@@ -198,14 +200,14 @@
 	NodeArray			m_contiguousNodes;
 	QuantizedNodeArray	m_quantizedLeafNodes;
 	QuantizedNodeArray	m_quantizedContiguousNodes;
-	
+
 	btTraversalMode	m_traversalMode;
 	BvhSubtreeInfoArray		m_SubtreeHeaders;
 
 	//This is only used for serialization so we don't have to add serialization directly to btAlignedObjectArray
 	mutable int m_subtreeHeaderCount;
 
-	
+
 
 
 
@@ -248,19 +250,19 @@
 		if (m_useQuantization)
 		{
 			return unQuantize(&m_quantizedLeafNodes[nodeIndex].m_quantizedAabbMax[0]);
-		} 
+		}
 		//non-quantized
 		return m_leafNodes[nodeIndex].m_aabbMaxOrg;
-		
+
 	}
 
-	
+
 	void	setInternalNodeEscapeIndex(int nodeIndex, int escapeIndex)
 	{
 		if (m_useQuantization)
 		{
 			m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = -escapeIndex;
-		} 
+		}
 		else
 		{
 			m_contiguousNodes[nodeIndex].m_escapeIndex = escapeIndex;
@@ -268,7 +270,7 @@
 
 	}
 
-	void mergeInternalNodeAabb(int nodeIndex,const btVector3& newAabbMin,const btVector3& newAabbMax) 
+	void mergeInternalNodeAabb(int nodeIndex,const btVector3& newAabbMin,const btVector3& newAabbMax)
 	{
 		if (m_useQuantization)
 		{
@@ -289,7 +291,7 @@
 		{
 			//non-quantized
 			m_contiguousNodes[nodeIndex].m_aabbMinOrg.setMin(newAabbMin);
-			m_contiguousNodes[nodeIndex].m_aabbMaxOrg.setMax(newAabbMax);		
+			m_contiguousNodes[nodeIndex].m_aabbMaxOrg.setMax(newAabbMax);
 		}
 	}
 
@@ -299,14 +301,14 @@
 
 protected:
 
-	
+
 
 	void	buildTree	(int startIndex,int endIndex);
 
 	int	calcSplittingAxis(int startIndex,int endIndex);
 
 	int	sortAndCalcSplittingIndex(int startIndex,int endIndex,int splitAxis);
-	
+
 	void	walkStacklessTree(btNodeOverlapCallback* nodeCallback,const btVector3& aabbMin,const btVector3& aabbMax) const;
 
 	void	walkStacklessQuantizedTreeAgainstRay(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex,int endNodeIndex) const;
@@ -321,21 +323,21 @@
 
 	///use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
 	void	walkRecursiveQuantizedTreeAgainstQuantizedTree(const btQuantizedBvhNode* treeNodeA,const btQuantizedBvhNode* treeNodeB,btNodeOverlapCallback* nodeCallback) const;
-	
+
 
 
 
 	void	updateSubtreeHeaders(int leftChildNodexIndex,int rightChildNodexIndex);
 
 public:
-	
+
 	BT_DECLARE_ALIGNED_ALLOCATOR();
 
 	btQuantizedBvh();
 
 	virtual ~btQuantizedBvh();
 
-	
+
 	///***************************************** expert/internal use only *************************
 	void	setQuantizationValues(const btVector3& bvhAabbMin,const btVector3& bvhAabbMax,btScalar quantizationMargin=btScalar(1.0));
 	QuantizedNodeArray&	getLeafNodeArray() {			return	m_quantizedLeafNodes;	}
@@ -426,7 +428,7 @@
 		quantize(out,clampedPoint,isMax);
 
 	}
-	
+
 	SIMD_FORCE_INLINE btVector3	unQuantize(const unsigned short* vecIn) const
 	{
 			btVector3	vecOut;
@@ -446,7 +448,7 @@
 
 
 	SIMD_FORCE_INLINE QuantizedNodeArray&	getQuantizedNodeArray()
-	{	
+	{
 		return	m_quantizedContiguousNodes;
 	}
 
@@ -470,7 +472,7 @@
 	static unsigned int getAlignmentSerializationPadding();
 //////////////////////////////////////////////////////////////////////
 
-	
+
 	virtual	int	calculateSerializeBufferSizeNew() const;
 
 	///fills the dataBuffer and returns the struct name (and 0 on failure)
@@ -548,7 +550,7 @@
 	btBvhSubtreeInfoData	*m_subTreeInfoPtr;
 	int					m_traversalMode;
 	int					m_numSubtreeHeaders;
-	
+
 };
 
 struct	btQuantizedBvhDoubleData
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/CMakeLists.txt c/bullet-2.77/src/BulletCollision/CMakeLists.txt
--- a/bullet-2.77/src/BulletCollision/CMakeLists.txt	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/CMakeLists.txt	2018-07-16 12:04:11.000000000 +0200
@@ -252,10 +252,8 @@
 				INSTALL(TARGETS BulletCollision DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS BulletCollision DESTINATION lib${LIB_SUFFIX})
-				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
-DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h" PATTERN ".svn" EXCLUDE PATTERN "CMakeFiles" EXCLUDE)
-				INSTALL(FILES ../btBulletCollisionCommon.h
-DESTINATION ${INCLUDE_INSTALL_DIR}/BulletCollision)
+				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} DESTINATION include FILES_MATCHING PATTERN "*.h")
+				INSTALL(FILES ../btBulletCollisionCommon.h DESTINATION include/BulletCollision)
 			ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 		ENDIF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 		
@@ -272,4 +270,4 @@
 		
 		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
-ENDIF (INSTALL_LIBS)
+ENDIF (INSTALL_LIBS)
\ No newline at end of file
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/CollisionDispatch/btBoxBoxDetector.cpp c/bullet-2.77/src/BulletCollision/CollisionDispatch/btBoxBoxDetector.cpp
--- a/bullet-2.77/src/BulletCollision/CollisionDispatch/btBoxBoxDetector.cpp	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/CollisionDispatch/btBoxBoxDetector.cpp	2018-07-16 12:04:11.000000000 +0200
@@ -345,20 +345,6 @@
     } \
   }
 
-  btScalar fudge2 (1.0e-5f);
-
-  Q11 += fudge2;
-  Q12 += fudge2;
-  Q13 += fudge2;
-
-  Q21 += fudge2;
-  Q22 += fudge2;
-  Q23 += fudge2;
-
-  Q31 += fudge2;
-  Q32 += fudge2;
-  Q33 += fudge2;
-
   // separating axis = u1 x (v1,v2,v3)
   TST(pp[2]*R21-pp[1]*R31,(A[1]*Q31+A[2]*Q21+B[1]*Q13+B[2]*Q12),0,-R31,R21,7);
   TST(pp[2]*R22-pp[1]*R32,(A[1]*Q32+A[2]*Q22+B[0]*Q13+B[2]*Q11),0,-R32,R22,8);
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionObject.h c/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionObject.h
--- a/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionObject.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionObject.h	2018-07-16 12:04:11.000000000 +0200
@@ -128,13 +128,12 @@
 	enum	CollisionObjectTypes
 	{
 		CO_COLLISION_OBJECT =1,
-		CO_RIGID_BODY=2,
+		CO_RIGID_BODY,
 		///CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
 		///It is useful for collision sensors, explosion objects, character controller etc.
-		CO_GHOST_OBJECT=4,
-		CO_SOFT_BODY=8,
-		CO_HF_FLUID=16,
-		CO_USER_TYPE=32
+		CO_GHOST_OBJECT,
+		CO_SOFT_BODY,
+		CO_HF_FLUID
 	};
 
 	SIMD_FORCE_INLINE bool mergesSimulationIslands() const
@@ -298,6 +297,13 @@
 	}
 
 
+	// DEFOLD MOD only existed in btRigidBody before
+	//is this rigidbody added to a btCollisionWorld/btDynamicsWorld/btBroadphase?
+	bool isInWorld() const
+	{
+	    return m_broadphaseHandle != 0;
+	}
+
 	SIMD_FORCE_INLINE btBroadphaseProxy*	getBroadphaseHandle()
 	{
 		return m_broadphaseHandle;
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.cpp c/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.cpp
--- a/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.cpp	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.cpp	2018-07-16 12:04:11.000000000 +0200
@@ -434,13 +434,11 @@
 					btCollisionShape* saveCollisionShape = collisionObject->getCollisionShape();
 					collisionObject->internalSetTemporaryCollisionShape((btCollisionShape*)childCollisionShape);
                     struct LocalInfoAdder2 : public RayResultCallback {
-						RayResultCallback* m_userCallback;
 						int m_i;
+						RayResultCallback* m_userCallback;
                         LocalInfoAdder2 (int i, RayResultCallback *user)
-							: m_userCallback(user),
-							m_i(i)
+							: m_i(i), m_userCallback(user) 
 						{ 
-							m_closestHitFraction = m_userCallback->m_closestHitFraction;
 						}
 						virtual btScalar addSingleResult (btCollisionWorld::LocalRayResult &r, bool b)
                             {
@@ -449,14 +447,13 @@
                                     shapeInfo.m_triangleIndex = m_i;
                                     if (r.m_localShapeInfo == NULL)
                                         r.m_localShapeInfo = &shapeInfo;
-
-									const btScalar result = m_userCallback->addSingleResult(r, b);
-									m_closestHitFraction = m_userCallback->m_closestHitFraction;
-									return result;
+                                    return m_userCallback->addSingleResult(r, b);
                             }
                     };
 
                     LocalInfoAdder2 my_cb(i, &resultCallback);
+					my_cb.m_closestHitFraction = resultCallback.m_closestHitFraction;
+					
 
 					rayTestSingle(rayFromTrans,rayToTrans,
 						collisionObject,
@@ -663,10 +660,7 @@
 							int m_i;
 
                             LocalInfoAdder (int i, ConvexResultCallback *user)
-								: m_userCallback(user), m_i(i)
-							{
-								m_closestHitFraction = m_userCallback->m_closestHitFraction;
-							}
+                                : m_userCallback(user),m_i(i) { }
                             virtual btScalar addSingleResult (btCollisionWorld::LocalConvexResult&	r,	bool b)
                             {
                                     btCollisionWorld::LocalShapeInfo	shapeInfo;
@@ -674,15 +668,12 @@
                                     shapeInfo.m_triangleIndex = m_i;
                                     if (r.m_localShapeInfo == NULL)
                                         r.m_localShapeInfo = &shapeInfo;
-									const btScalar result = m_userCallback->addSingleResult(r, b);
-									m_closestHitFraction = m_userCallback->m_closestHitFraction;
-									return result;
-                                    
+                                    return m_userCallback->addSingleResult(r, b);
                             }
                     };
 
                     LocalInfoAdder my_cb(i, &resultCallback);
-					
+					my_cb.m_closestHitFraction = resultCallback.m_closestHitFraction;
 
 					objectQuerySingle(castShape, convexFromTrans,convexToTrans,
 						collisionObject,
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.h c/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.h
--- a/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/CollisionDispatch/btCollisionWorld.h	2018-07-16 12:04:11.000000000 +0200
@@ -264,45 +264,6 @@
 		}
 	};
 
-	struct	AllHitsRayResultCallback : public RayResultCallback
-	{
-		AllHitsRayResultCallback(const btVector3&	rayFromWorld,const btVector3&	rayToWorld)
-		:m_rayFromWorld(rayFromWorld),
-		m_rayToWorld(rayToWorld)
-		{
-		}
-
-		btAlignedObjectArray<btCollisionObject*>		m_collisionObjects;
-
-		btVector3	m_rayFromWorld;//used to calculate hitPointWorld from hitFraction
-		btVector3	m_rayToWorld;
-
-		btAlignedObjectArray<btVector3>	m_hitNormalWorld;
-		btAlignedObjectArray<btVector3>	m_hitPointWorld;
-		btAlignedObjectArray<btScalar> m_hitFractions;
-			
-		virtual	btScalar	addSingleResult(LocalRayResult& rayResult,bool normalInWorldSpace)
-		{
-			m_collisionObject = rayResult.m_collisionObject;
-			m_collisionObjects.push_back(rayResult.m_collisionObject);
-			btVector3 hitNormalWorld;
-			if (normalInWorldSpace)
-			{
-				hitNormalWorld = rayResult.m_hitNormalLocal;
-			} else
-			{
-				///need to transform normal into worldspace
-				hitNormalWorld = m_collisionObject->getWorldTransform().getBasis()*rayResult.m_hitNormalLocal;
-			}
-			m_hitNormalWorld.push_back(hitNormalWorld);
-			btVector3 hitPointWorld;
-			hitPointWorld.setInterpolate3(m_rayFromWorld,m_rayToWorld,rayResult.m_hitFraction);
-			m_hitPointWorld.push_back(hitPointWorld);
-			m_hitFractions.push_back(rayResult.m_hitFraction);
-			return m_closestHitFraction;
-		}
-	};
-
 
 	struct LocalConvexResult
 	{
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp c/bullet-2.77/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp
--- a/bullet-2.77/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp	2018-07-16 12:04:11.000000000 +0200
@@ -357,13 +357,7 @@
 	} else
 #endif //USE_SEPDISTANCE_UTIL2
 	{
-		if (dispatchInfo.m_convexMaxDistanceUseCPT)
-		{
-			input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactProcessingThreshold();
-		} else
-		{
-			input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactBreakingThreshold();
-		}
+		input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactBreakingThreshold();
 		input.m_maximumDistanceSquared*= input.m_maximumDistanceSquared;
 	}
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btBoxCollision.h c/bullet-2.77/src/BulletCollision/Gimpact/btBoxCollision.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btBoxCollision.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btBoxCollision.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define BT_BOX_COLLISION_H_INCLUDED
 
 /*! \file gim_box_collision.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btClipPolygon.h c/bullet-2.77/src/BulletCollision/Gimpact/btClipPolygon.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btClipPolygon.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btClipPolygon.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define BT_CLIP_POLYGON_H_INCLUDED
 
 /*! \file btClipPolygon.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btContactProcessing.h c/bullet-2.77/src/BulletCollision/Gimpact/btContactProcessing.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btContactProcessing.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btContactProcessing.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define BT_CONTACT_H_INCLUDED
 
 /*! \file gim_contact.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.cpp c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.cpp
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.cpp	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.cpp	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file gim_box_set.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.h c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactBvh.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_BOX_SET_H_INCLUDED
 
 /*! \file gim_box_set.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file btGImpactShape.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactMassUtil.h c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactMassUtil.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactMassUtil.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactMassUtil.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file btGImpactMassUtil.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.cpp c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.cpp
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.cpp	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file gim_box_set.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.h c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGImpactQuantizedBvh.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_QUANTIZED_SET_H_INCLUDED
 
 /*! \file btGImpactQuantizedBvh.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.cpp c/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.cpp
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.cpp	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.cpp	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file btGenericPoolAllocator.cpp
-\author Francisco Leon Najera. email projectileman@yahoo.com
+\author Francisco Len Nßjera. email projectileman@yahoo.com
 
 General purpose allocator class
 */
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.h c/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGenericPoolAllocator.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file btGenericPoolAllocator.h
-\author Francisco Leon Najera. email projectileman@yahoo.com
+\author Francisco Len Nßjera. email projectileman@yahoo.com
 
 General purpose allocator class
 */
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btGeometryOperations.h c/bullet-2.77/src/BulletCollision/Gimpact/btGeometryOperations.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btGeometryOperations.h	2018-07-16 11:55:30.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btGeometryOperations.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define BT_BASIC_GEOMETRY_OPERATIONS_H_INCLUDED
 
 /*! \file btGeometryOperations.h
-*\author Francisco Leon Najera
+*\author Francisco Len Nßjera
 
 */
 /*
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btQuantization.h c/bullet-2.77/src/BulletCollision/Gimpact/btQuantization.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btQuantization.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btQuantization.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define BT_QUANTIZATION_H_INCLUDED
 
 /*! \file btQuantization.h
-*\author Francisco Leon Najera
+*\author Francisco Len Nßjera
 
 */
 /*
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.cpp c/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.cpp
--- a/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.cpp	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file btGImpactTriangleShape.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.h c/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/btTriangleShapeEx.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,5 +1,5 @@
 /*! \file btGImpactShape.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 This source file is part of GIMPACT Library.
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_array.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_array.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_array.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_array.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef GIM_ARRAY_H_INCLUDED
 #define GIM_ARRAY_H_INCLUDED
 /*! \file gim_array.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_basic_geometry_operations.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_basic_geometry_operations.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_basic_geometry_operations.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_basic_geometry_operations.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_BASIC_GEOMETRY_OPERATIONS_H_INCLUDED
 
 /*! \file gim_basic_geometry_operations.h
-*\author Francisco Leon Najera
+*\author Francisco Len Nßjera
 type independant geometry routines
 
 */
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_bitset.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_bitset.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_bitset.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_bitset.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef GIM_BITSET_H_INCLUDED
 #define GIM_BITSET_H_INCLUDED
 /*! \file gim_bitset.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_box_collision.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_box_collision.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_box_collision.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_box_collision.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_BOX_COLLISION_H_INCLUDED
 
 /*! \file gim_box_collision.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_box_set.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_box_set.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_box_set.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_box_set.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_BOX_SET_H_INCLUDED
 
 /*! \file gim_box_set.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_clip_polygon.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_clip_polygon.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_clip_polygon.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_clip_polygon.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_CLIP_POLYGON_H_INCLUDED
 
 /*! \file gim_tri_collision.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_contact.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_contact.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_contact.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_contact.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_CONTACT_H_INCLUDED
 
 /*! \file gim_contact.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_geom_types.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_geom_types.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_geom_types.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_geom_types.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_GEOM_TYPES_H_INCLUDED
 
 /*! \file gim_geom_types.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_geometry.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_geometry.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_geometry.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_geometry.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_GEOMETRY_H_INCLUDED
 
 /*! \file gim_geometry.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_hash_table.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_hash_table.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_hash_table.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_hash_table.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef GIM_HASH_TABLE_H_INCLUDED
 #define GIM_HASH_TABLE_H_INCLUDED
 /*! \file gim_trimesh_data.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_linear_math.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_linear_math.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_linear_math.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_linear_math.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_LINEAR_H_INCLUDED
 
 /*! \file gim_linear_math.h
-*\author Francisco Leon Najera
+*\author Francisco Len Nßjera
 Type Independant Vector and matrix operations.
 */
 /*
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_math.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_math.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_math.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_math.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef GIM_MATH_H_INCLUDED
 #define GIM_MATH_H_INCLUDED
 /*! \file gim_math.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_memory.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_memory.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_memory.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_memory.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef GIM_MEMORY_H_INCLUDED
 #define GIM_MEMORY_H_INCLUDED
 /*! \file gim_memory.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_radixsort.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_radixsort.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_radixsort.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_radixsort.h	2018-07-16 12:04:12.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef GIM_RADIXSORT_H_INCLUDED
 #define GIM_RADIXSORT_H_INCLUDED
 /*! \file gim_radixsort.h
-\author Francisco Leon Najera.
+\author Francisco Len Nßjera.
 Based on the work of Michael Herf : "fast floating-point radix sort"
 Avaliable on http://www.stereopsis.com/radix.html
 */
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.cpp c/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.cpp
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.cpp	2018-07-16 12:04:12.000000000 +0200
@@ -1,6 +1,6 @@
 
 /*! \file gim_tri_collision.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.h c/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.h
--- a/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletCollision/Gimpact/gim_tri_collision.h	2018-07-16 12:04:12.000000000 +0200
@@ -2,7 +2,7 @@
 #define GIM_TRI_COLLISION_H_INCLUDED
 
 /*! \file gim_tri_collision.h
-\author Francisco Leon Najera
+\author Francisco Len Nßjera
 */
 /*
 -----------------------------------------------------------------------------
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/CMakeLists.txt c/bullet-2.77/src/BulletDynamics/CMakeLists.txt
--- a/bullet-2.77/src/BulletDynamics/CMakeLists.txt	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/CMakeLists.txt	2018-07-16 12:04:12.000000000 +0200
@@ -79,8 +79,6 @@
 
 
 ADD_LIBRARY(BulletDynamics ${BulletDynamics_SRCS} ${BulletDynamics_HDRS})
-SET_TARGET_PROPERTIES(BulletDynamics PROPERTIES VERSION ${BULLET_VERSION})
-SET_TARGET_PROPERTIES(BulletDynamics PROPERTIES SOVERSION ${BULLET_VERSION})
 IF (BUILD_SHARED_LIBS)
 	TARGET_LINK_LIBRARIES(BulletDynamics BulletCollision LinearMath)
 ENDIF (BUILD_SHARED_LIBS)
@@ -92,11 +90,8 @@
 				INSTALL(TARGETS BulletDynamics DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS BulletDynamics DESTINATION lib${LIB_SUFFIX})
-				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
-DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
-".svn" EXCLUDE PATTERN "CMakeFiles" EXCLUDE)
-				INSTALL(FILES ../btBulletDynamicsCommon.h
-DESTINATION ${INCLUDE_INSTALL_DIR}/BulletDynamics)
+				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} DESTINATION include FILES_MATCHING PATTERN "*.h")
+				INSTALL(FILES ../btBulletDynamicsCommon.h DESTINATION include/BulletDynamics)
 			ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 		ENDIF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btContactSolverInfo.h c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btContactSolverInfo.h
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btContactSolverInfo.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btContactSolverInfo.h	2018-07-16 12:04:12.000000000 +0200
@@ -35,7 +35,7 @@
 	
 
 	btScalar	m_tau;
-	btScalar	m_damping;//global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
+	btScalar	m_damping;
 	btScalar	m_friction;
 	btScalar	m_timeStep;
 	btScalar	m_restitution;
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btHingeConstraint.cpp c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btHingeConstraint.cpp
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btHingeConstraint.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btHingeConstraint.cpp	2018-07-16 12:04:12.000000000 +0200
@@ -773,23 +773,17 @@
 	for (i=0; i<3; i++) info->m_J1angularAxis[s2+i] = tmpA[i];
     for (i=0; i<3; i++) info->m_J2angularAxis[s2+i] = -tmpB[i];
 
-	btScalar k = info->fps * info->erp;
-
-	if (!m_angularOnly)
-	{
-		for (i=0; i<3; i++) info->m_J1linearAxis[s0+i] = p[i];
-		for (i=0; i<3; i++) info->m_J1linearAxis[s1+i] = q[i];
-		for (i=0; i<3; i++) info->m_J1linearAxis[s2+i] = ax1[i];
-	
+	for (i=0; i<3; i++) info->m_J1linearAxis[s0+i] = p[i];
+	for (i=0; i<3; i++) info->m_J1linearAxis[s1+i] = q[i];
+	for (i=0; i<3; i++) info->m_J1linearAxis[s2+i] = ax1[i];
 	// compute three elements of right hand side
-	
-		btScalar rhs = k * p.dot(ofs);
-		info->m_constraintError[s0] = rhs;
-		rhs = k * q.dot(ofs);
-		info->m_constraintError[s1] = rhs;
-		rhs = k * ax1.dot(ofs);
-		info->m_constraintError[s2] = rhs;
-	}
+	btScalar k = info->fps * info->erp;
+	btScalar rhs = k * p.dot(ofs);
+	info->m_constraintError[s0] = rhs;
+	rhs = k * q.dot(ofs);
+	info->m_constraintError[s1] = rhs;
+	rhs = k * ax1.dot(ofs);
+	info->m_constraintError[s2] = rhs;
 	// the hinge axis should be the only unconstrained
 	// rotational axis, the angular velocity of the two bodies perpendicular to
 	// the hinge axis should be equal. thus the constraint equations are
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btPoint2PointConstraint.cpp c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btPoint2PointConstraint.cpp
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btPoint2PointConstraint.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btPoint2PointConstraint.cpp	2018-07-16 12:04:13.000000000 +0200
@@ -159,7 +159,6 @@
 			info->m_upperLimit[j*info->rowskip] = impulseClamp;
 		}
 	}
-	info->m_damping = m_setting.m_damping;
 	
 }
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp	2018-07-16 12:04:13.000000000 +0200
@@ -852,7 +852,6 @@
 					btAssert(info2.rowskip*sizeof(btScalar)== sizeof(btSolverConstraint));
 					info2.m_constraintError = &currentConstraintRow->m_rhs;
 					currentConstraintRow->m_cfm = infoGlobal.m_globalCfm;
-					info2.m_damping = infoGlobal.m_damping;
 					info2.cfm = &currentConstraintRow->m_cfm;
 					info2.m_lowerLimit = &currentConstraintRow->m_lowerLimit;
 					info2.m_upperLimit = &currentConstraintRow->m_upperLimit;
@@ -900,7 +899,7 @@
 
 							btScalar restitution = 0.f;
 							btScalar positionalError = solverConstraint.m_rhs;//already filled in by getConstraintInfo2
-							btScalar	velocityError = restitution - rel_vel * info2.m_damping;
+							btScalar	velocityError = restitution - rel_vel;// * damping;
 							btScalar	penetrationImpulse = positionalError*solverConstraint.m_jacDiagABInv;
 							btScalar	velocityImpulse = velocityError *solverConstraint.m_jacDiagABInv;
 							solverConstraint.m_rhs = penetrationImpulse+velocityImpulse;
@@ -1199,10 +1198,4 @@
 	m_btSeed2 = 0;
 }
 
-btRigidBody& btSequentialImpulseConstraintSolver::getFixedBody()
-{
-	static btRigidBody s_fixed(0, 0,0);
-	s_fixed.setMassProps(btScalar(0.),btVector3(btScalar(0.),btScalar(0.),btScalar(0.)));
-	return s_fixed;
-}
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h	2018-07-16 12:04:13.000000000 +0200
@@ -81,8 +81,12 @@
 	void	resolveSingleConstraintRowLowerLimitSIMD(btRigidBody& body1,btRigidBody& body2,const btSolverConstraint& contactConstraint);
 		
 protected:
-	static btRigidBody& getFixedBody();
-	
+	static btRigidBody& getFixedBody()
+	{
+		static btRigidBody s_fixed(0, 0,0);
+		s_fixed.setMassProps(btScalar(0.),btVector3(btScalar(0.),btScalar(0.),btScalar(0.)));
+		return s_fixed;
+	}	
 	virtual void solveGroupCacheFriendlySplitImpulseIterations(btCollisionObject** bodies,int numBodies,btPersistentManifold** manifoldPtr, int numManifolds,btTypedConstraint** constraints,int numConstraints,const btContactSolverInfo& infoGlobal,btIDebugDraw* debugDrawer,btStackAlloc* stackAlloc);
 	virtual btScalar solveGroupCacheFriendlyFinish(btCollisionObject** bodies ,int numBodies,btPersistentManifold** manifoldPtr, int numManifolds,btTypedConstraint** constraints,int numConstraints,const btContactSolverInfo& infoGlobal,btIDebugDraw* debugDrawer,btStackAlloc* stackAlloc);
 	btScalar solveSingleIteration(int iteration, btCollisionObject** bodies ,int numBodies,btPersistentManifold** manifoldPtr, int numManifolds,btTypedConstraint** constraints,int numConstraints,const btContactSolverInfo& infoGlobal,btIDebugDraw* debugDrawer,btStackAlloc* stackAlloc);
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.cpp c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.cpp
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.cpp	2018-07-16 12:04:13.000000000 +0200
@@ -133,10 +133,4 @@
 	return "btTypedConstraintData";
 }
 
-btRigidBody& btTypedConstraint::getFixedBody()
-{
-	static btRigidBody s_fixed(0, 0,0);
-	s_fixed.setMassProps(btScalar(0.),btVector3(btScalar(0.),btScalar(0.),btScalar(0.)));
-	return s_fixed;
-}
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.h c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.h
--- a/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/ConstraintSolver/btTypedConstraint.h	2018-07-16 12:04:13.000000000 +0200
@@ -53,13 +53,7 @@
 class btTypedConstraint : public btTypedObject
 {
 	int	m_userConstraintType;
-
-	union
-	{
-		int	m_userConstraintId;
-		void* m_userConstraintPtr;
-	};
-
+	int	m_userConstraintId;
 	bool m_needsFeedback;
 
 	btTypedConstraint&	operator=(btTypedConstraint&	other)
@@ -78,7 +72,13 @@
 	///internal method used by the constraint solver, don't use them directly
 	btScalar getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact);
 	
-	static btRigidBody& getFixedBody();
+	static btRigidBody& getFixedBody()
+	{
+		static btRigidBody s_fixed(0, 0,0);
+		s_fixed.setMassProps(btScalar(0.),btVector3(btScalar(0.),btScalar(0.),btScalar(0.)));
+		return s_fixed;
+	}	
+
 
 public:
 
@@ -119,9 +119,6 @@
 		int *findex;
 		// number of solver iterations
 		int m_numIterations;
-
-		//damping of the velocity
-		btScalar	m_damping;
 	};
 
 	///internal method used by the constraint solver, don't use them directly
@@ -195,16 +192,6 @@
 		return m_userConstraintId;
 	}
 
-	void	setUserConstraintPtr(void* ptr)
-	{
-		m_userConstraintPtr = ptr;
-	}
-
-	void*	getUserConstraintPtr()
-	{
-		return m_userConstraintPtr;
-	}
-
 	int getUid() const
 	{
 		return m_userConstraintId;   
@@ -268,13 +255,13 @@
 	}
 	else if(angleInRadians < angleLowerLimitInRadians)
 	{
-		btScalar diffLo = btFabs(btNormalizeAngle(angleLowerLimitInRadians - angleInRadians));
+		btScalar diffLo = btNormalizeAngle(angleLowerLimitInRadians - angleInRadians); // this is positive
 		btScalar diffHi = btFabs(btNormalizeAngle(angleUpperLimitInRadians - angleInRadians));
 		return (diffLo < diffHi) ? angleInRadians : (angleInRadians + SIMD_2_PI);
 	}
 	else if(angleInRadians > angleUpperLimitInRadians)
 	{
-		btScalar diffHi = btFabs(btNormalizeAngle(angleInRadians - angleUpperLimitInRadians));
+		btScalar diffHi = btNormalizeAngle(angleInRadians - angleUpperLimitInRadians); // this is positive
 		btScalar diffLo = btFabs(btNormalizeAngle(angleInRadians - angleLowerLimitInRadians));
 		return (diffLo < diffHi) ? (angleInRadians - SIMD_2_PI) : angleInRadians;
 	}
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/Dynamics/btActionInterface.h c/bullet-2.77/src/BulletDynamics/Dynamics/btActionInterface.h
--- a/bullet-2.77/src/BulletDynamics/Dynamics/btActionInterface.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/Dynamics/btActionInterface.h	2018-07-16 12:04:13.000000000 +0200
@@ -27,8 +27,12 @@
 {
 protected:
 
-	static btRigidBody& getFixedBody();
-	
+	static btRigidBody& getFixedBody()
+	{
+		static btRigidBody s_fixed(0, 0,0);
+		s_fixed.setMassProps(btScalar(0.),btVector3(btScalar(0.),btScalar(0.),btScalar(0.)));
+		return s_fixed;
+	}	
 	
 public:
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp c/bullet-2.77/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp
--- a/bullet-2.77/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp	2018-07-16 12:04:13.000000000 +0200
@@ -52,7 +52,7 @@
 :btDynamicsWorld(dispatcher,pairCache,collisionConfiguration),
 m_constraintSolver(constraintSolver),
 m_gravity(0,-10,0),
-m_localTime(0),
+m_localTime(btScalar(1.)/btScalar(60.)),
 m_synchronizeAllMotionStates(false),
 m_profileTimings(0)
 {
@@ -1127,7 +1127,7 @@
 	for (i=0;i<m_collisionObjects.size();i++)
 	{
 		btCollisionObject* colObj = m_collisionObjects[i];
-		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
+		if (colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY)
 		{
 			int len = colObj->calculateSerializeBufferSize();
 			btChunk* chunk = serializer->allocate(len,1);
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/Dynamics/btRigidBody.h c/bullet-2.77/src/BulletDynamics/Dynamics/btRigidBody.h
--- a/bullet-2.77/src/BulletDynamics/Dynamics/btRigidBody.h	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/Dynamics/btRigidBody.h	2018-07-16 12:04:13.000000000 +0200
@@ -188,13 +188,13 @@
 	///but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast
 	static const btRigidBody*	upcast(const btCollisionObject* colObj)
 	{
-		if (colObj->getInternalType()&btCollisionObject::CO_RIGID_BODY)
+		if (colObj->getInternalType()==btCollisionObject::CO_RIGID_BODY)
 			return (const btRigidBody*)colObj;
 		return 0;
 	}
 	static btRigidBody*	upcast(btCollisionObject* colObj)
 	{
-		if (colObj->getInternalType()&btCollisionObject::CO_RIGID_BODY)
+		if (colObj->getInternalType()==btCollisionObject::CO_RIGID_BODY)
 			return (btRigidBody*)colObj;
 		return 0;
 	}
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletDynamics/Vehicle/btRaycastVehicle.cpp c/bullet-2.77/src/BulletDynamics/Vehicle/btRaycastVehicle.cpp
--- a/bullet-2.77/src/BulletDynamics/Vehicle/btRaycastVehicle.cpp	2018-07-16 11:55:31.000000000 +0200
+++ c/bullet-2.77/src/BulletDynamics/Vehicle/btRaycastVehicle.cpp	2018-07-16 12:04:13.000000000 +0200
@@ -22,12 +22,7 @@
 #include "LinearMath/btIDebugDraw.h"
 #include "BulletDynamics/ConstraintSolver/btContactConstraint.h"
 
-btRigidBody& btActionInterface::getFixedBody()
-{
-	static btRigidBody s_fixed(0, 0,0);
-	s_fixed.setMassProps(btScalar(0.),btVector3(btScalar(0.),btScalar(0.),btScalar(0.)));
-	return s_fixed;
-}
+
 
 btRaycastVehicle::btRaycastVehicle(const btVehicleTuning& tuning,btRigidBody* chassis,	btVehicleRaycaster* raycaster )
 :m_vehicleRaycaster(raycaster),
diff -u -r --strip-trailing-cr a/bullet-2.77/src/BulletSoftBody/btSoftBodyInternals.h c/bullet-2.77/src/BulletSoftBody/btSoftBodyInternals.h
--- a/bullet-2.77/src/BulletSoftBody/btSoftBodyInternals.h	2018-07-16 11:55:32.000000000 +0200
+++ c/bullet-2.77/src/BulletSoftBody/btSoftBodyInternals.h	2018-07-16 12:09:04.000000000 +0200
@@ -40,7 +40,7 @@
 	const T&				operator()(int c,int r) const			{ return(store[index(c,r)]); }
 	btAlignedObjectArray<T>	store;
 	int						dim;
-};	
+};
 
 //
 // btSoftBodyCollisionShape
@@ -70,7 +70,7 @@
 	///getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.
 	virtual void getAabb(const btTransform& t,btVector3& aabbMin,btVector3& aabbMax) const
 	{
-		/* t should be identity, but better be safe than...fast? */ 
+		/* t should be identity, but better be safe than...fast? */
 		const btVector3	mins=m_body->m_bounds[0];
 		const btVector3	maxs=m_body->m_bounds[1];
 		const btVector3	crns[]={t*btVector3(mins.x(),mins.y(),mins.z()),
@@ -91,7 +91,7 @@
 
 
 	virtual void	setLocalScaling(const btVector3& /*scaling*/)
-	{		
+	{
 		///na
 	}
 	virtual const btVector3& getLocalScaling() const
@@ -172,8 +172,7 @@
 template <typename T>
 static inline void			ZeroInitialize(T& value)
 {
-	static const T	zerodummy;
-	value=zerodummy;
+	memset(&value, 0, sizeof(value));
 }
 //
 template <typename T>
@@ -320,7 +319,7 @@
 
 //
 static inline btMatrix3x3	ImpulseMatrix(	btScalar ima,const btMatrix3x3& iia,const btVector3& ra,
-										  btScalar imb,const btMatrix3x3& iib,const btVector3& rb)	
+										  btScalar imb,const btMatrix3x3& iib,const btVector3& rb)
 {
 	return(Add(MassMatrix(ima,iia,ra),MassMatrix(imb,iib,rb)).inverse());
 }
@@ -354,7 +353,7 @@
 	const btVector3	d=b-a;
 	const btScalar	m2=d.length2();
 	if(m2>SIMD_EPSILON)
-	{	
+	{
 		const btScalar	t=Clamp<btScalar>(-btDot(a,d)/m2,0,1);
 		const btVector3	p=a+d*t;
 		const btScalar	l2=p.length2();
@@ -385,7 +384,7 @@
 			if(	(btDot(btCross(a-p,b-p),q)>0)&&
 				(btDot(btCross(b-p,c-p),q)>0)&&
 				(btDot(btCross(c-p,a-p),q)>0))
-			{			
+			{
 				prj=p;
 				sqd=k2;
 			}
@@ -529,11 +528,11 @@
 {
 	const btScalar	dtim=dt*n.m_im;
 	if((f*dtim).length2()>n.m_v.length2())
-	{/* Clamp	*/ 
-		n.m_f-=ProjectOnAxis(n.m_v,f.normalized())/dtim;						
+	{/* Clamp	*/
+		n.m_f-=ProjectOnAxis(n.m_v,f.normalized())/dtim;
 	}
 	else
-	{/* Apply	*/ 
+	{/* Apply	*/
 		n.m_f+=f;
 	}
 }
@@ -572,7 +571,7 @@
 				const btScalar	w=(a[q][q]-a[p][p])/(2*a[p][q]);
 				const btScalar	z=btFabs(w);
 				const btScalar	t=w/(z*(btSqrt(1+w*w)+z));
-				if(t==t)/* [WARNING] let hope that one does not get thrown aways by some compilers... */ 
+				if(t==t)/* [WARNING] let hope that one does not get thrown aways by some compilers... */
 				{
 					const btScalar	c=1/btSqrt(t*t+1);
 					const btScalar	s=c*t;
@@ -630,9 +629,9 @@
 			const btScalar	ndet=q.determinant();
 			if(Sq(ndet-det)>accuracy) det=ndet; else break;
 		}
-		/* Final orthogonalization	*/ 
+		/* Final orthogonalization	*/
 		Orthogonalize(q);
-		/* Compute 'S'				*/ 
+		/* Compute 'S'				*/
 		s=q.transpose()*m;
 	}
 	else
@@ -682,7 +681,7 @@
 				const btVector3		vrel=va-vb;
 				const btScalar		rvac=btDot(vrel,norm);
 				 btScalar		depth=res.distance-m_margin;
-				
+
 //				printf("depth=%f\n",depth);
 				const btVector3		iv=norm*rvac;
 				const btVector3		fv=vrel-iv;
@@ -697,7 +696,7 @@
 				joint.m_life		=	0;
 				joint.m_maxlife		=	0;
 				joint.m_split		=	1;
-				
+
 				joint.m_drift		=	depth*norm;
 
 				joint.m_normal		=	norm;
@@ -718,20 +717,20 @@
 	struct	CollideCL_RS : ClusterBase
 	{
 		btSoftBody*		psb;
-		
+
 		btCollisionObject*	m_colObj;
 		void		Process(const btDbvtNode* leaf)
 		{
 			btSoftBody::Cluster*		cluster=(btSoftBody::Cluster*)leaf->data;
 			btSoftClusterCollisionShape	cshape(cluster);
-			
+
 			const btConvexShape*		rshape=(const btConvexShape*)m_colObj->getCollisionShape();
 
 			///don't collide an anchored cluster with a static/kinematic object
 			if(m_colObj->isStaticOrKinematicObject() && cluster->m_containsAnchor)
 				return;
 
-			btGjkEpaSolver2::sResults	res;		
+			btGjkEpaSolver2::sResults	res;
 			if(btGjkEpaSolver2::SignedDistance(	&cshape,btTransform::getIdentity(),
 				rshape,m_colObj->getInterpolationWorldTransform(),
 				btVector3(1,0,0),res))
@@ -770,7 +769,7 @@
 			volume=btDbvtVolume::FromMM(mins,maxs);
 			volume.Expand(btVector3(1,1,1)*m_margin);
 			ps->m_cdbvt.collideTV(ps->m_cdbvt.m_root,volume,*this);
-		}	
+		}
 	};
 	//
 	// CollideCL_SS
@@ -794,7 +793,7 @@
 			{
 				btSoftClusterCollisionShape	csa(cla);
 				btSoftClusterCollisionShape	csb(clb);
-				btGjkEpaSolver2::sResults	res;		
+				btGjkEpaSolver2::sResults	res;
 				if(btGjkEpaSolver2::SignedDistance(	&csa,btTransform::getIdentity(),
 					&csb,btTransform::getIdentity(),
 					cla->m_com-clb->m_com,res))
@@ -813,7 +812,7 @@
 				static int count=0;
 				count++;
 				//printf("count=%d\n",count);
-				
+
 			}
 		}
 		void		Process(btSoftBody* psa,btSoftBody* psb)
@@ -825,7 +824,7 @@
 			bodies[0]	=	psa;
 			bodies[1]	=	psb;
 			psa->m_cdbvt.collideTT(psa->m_cdbvt.m_root,psb->m_cdbvt.m_root,*this);
-		}	
+		}
 	};
 	//
 	// CollideSDF_RS
@@ -854,7 +853,7 @@
 					const btMatrix3x3&	iwi=m_rigidBody?m_rigidBody->getInvInertiaTensorWorld() : iwiStatic;
 					const btVector3		ra=n.m_x-wtr.getOrigin();
 					const btVector3		va=m_rigidBody ? m_rigidBody->getVelocityInLocalPoint(ra)*psb->m_sst.sdt : btVector3(0,0,0);
-					const btVector3		vb=n.m_x-n.m_q;	
+					const btVector3		vb=n.m_x-n.m_q;
 					const btVector3		vr=vb-va;
 					const btScalar		dn=btDot(vr,c.m_cti.m_normal);
 					const btVector3		fv=vr-c.m_cti.m_normal*dn;
@@ -921,7 +920,7 @@
 					c.m_cfm[1]		=	mb/ms*psb[1]->m_cfg.kSHR;
 					psb[0]->m_scontacts.push_back(c);
 				}
-			}	
+			}
 		}
 		btSoftBody*		psb[2];
 		btScalar		mrg;
diff -u -r --strip-trailing-cr a/bullet-2.77/src/CMakeLists.txt c/bullet-2.77/src/CMakeLists.txt
--- a/bullet-2.77/src/CMakeLists.txt	2018-07-16 11:55:32.000000000 +0200
+++ c/bullet-2.77/src/CMakeLists.txt	2018-07-16 12:14:15.000000000 +0200
@@ -1,4 +1,4 @@
-SUBDIRS( MiniCL BulletMultiThreaded BulletSoftBody BulletCollision BulletDynamics LinearMath )
+SUBDIRS( MiniCL BulletSoftBody BulletCollision BulletDynamics LinearMath )
 
 IF(INSTALL_LIBS)
 	#INSTALL of other files requires CMake 2.6
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/CMakeLists.txt c/bullet-2.77/src/LinearMath/CMakeLists.txt
--- a/bullet-2.77/src/LinearMath/CMakeLists.txt	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/CMakeLists.txt	2018-07-16 12:04:14.000000000 +0200
@@ -49,9 +49,7 @@
 				INSTALL(TARGETS LinearMath DESTINATION .)
 			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 				INSTALL(TARGETS LinearMath DESTINATION lib${LIB_SUFFIX})
-				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
-DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
-".svn" EXCLUDE PATTERN "CMakeFiles" EXCLUDE)
+				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} DESTINATION include FILES_MATCHING PATTERN "*.h")
 			ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
 		ENDIF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btAlignedAllocator.cpp c/bullet-2.77/src/LinearMath/btAlignedAllocator.cpp
--- a/bullet-2.77/src/LinearMath/btAlignedAllocator.cpp	2018-07-16 11:55:32.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btAlignedAllocator.cpp	2018-07-16 12:04:14.000000000 +0200
@@ -160,8 +160,22 @@
 void*	btAlignedAllocInternal	(size_t size, int alignment)
 {
 	gNumAlignedAllocs++;
-	void* ptr;
+  void* ptr;
+#if defined (BT_HAS_ALIGNED_ALLOCATOR) || defined(__CELLOS_LV2__)
 	ptr = sAlignedAllocFunc(size, alignment);
+#else
+  char *real;
+  unsigned long offset;
+
+  real = (char *)sAllocFunc(size + sizeof(void *) + (alignment-1));
+  if (real) {
+    offset = (alignment - (unsigned long)(real + sizeof(void *))) & (alignment-1);
+    ptr = (void *)((real + sizeof(void *)) + offset);
+    *((void **)(ptr)-1) = (void *)(real);
+  } else {
+    ptr = (void *)(real);
+  }
+#endif  // defined (BT_HAS_ALIGNED_ALLOCATOR) || defined(__CELLOS_LV2__)
 //	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
 	return ptr;
 }
@@ -175,7 +189,16 @@
 
 	gNumAlignedFree++;
 //	printf("btAlignedFreeInternal %x\n",ptr);
+#if defined (BT_HAS_ALIGNED_ALLOCATOR) || defined(__CELLOS_LV2__)
 	sAlignedFreeFunc(ptr);
+#else
+  void* real;
+
+  if (ptr) {
+    real = *((void **)(ptr)-1);
+    sFreeFunc(real);
+  }
+#endif  // defined (BT_HAS_ALIGNED_ALLOCATOR) || defined(__CELLOS_LV2__)
 }
 
 #endif //BT_DEBUG_MEMORY_ALLOCATIONS
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btIDebugDraw.h c/bullet-2.77/src/LinearMath/btIDebugDraw.h
--- a/bullet-2.77/src/LinearMath/btIDebugDraw.h	2018-07-16 11:55:32.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btIDebugDraw.h	2018-07-16 12:04:14.000000000 +0200
@@ -59,7 +59,7 @@
 		drawLine (from, to, fromColor);
 	}
 
-	virtual void	drawSphere(btScalar radius, const btTransform& transform, const btVector3& color)
+	void	drawSphere(btScalar radius, const btTransform& transform, const btVector3& color)
 	{
 		btVector3 start = transform.getOrigin();
 
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btQuickprof.cpp c/bullet-2.77/src/LinearMath/btQuickprof.cpp
--- a/bullet-2.77/src/LinearMath/btQuickprof.cpp	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btQuickprof.cpp	2018-07-16 12:04:14.000000000 +0200
@@ -15,230 +15,11 @@
 
 #include "btQuickprof.h"
 
-#ifndef BT_NO_PROFILE
 
+#ifdef USE_BT_CLOCK
 
 static btClock gProfileClock;
 
-
-#ifdef __CELLOS_LV2__
-#include <sys/sys_time.h>
-#include <sys/time_util.h>
-#include <stdio.h>
-#endif
-
-#if defined (SUNOS) || defined (__SUNOS__) 
-#include <stdio.h> 
-#endif
-
-#if defined(WIN32) || defined(_WIN32)
-
-#define BT_USE_WINDOWS_TIMERS
-#define WIN32_LEAN_AND_MEAN
-#define NOWINRES
-#define NOMCX
-#define NOIME 
-
-#ifdef _XBOX
-	#include <Xtl.h>
-#else //_XBOX
-	#include <windows.h>
-#endif //_XBOX
-
-#include <time.h>
-
-
-#else //_WIN32
-#include <sys/time.h>
-#endif //_WIN32
-
-#define mymin(a,b) (a > b ? a : b)
-
-struct btClockData
-{
-
-#ifdef BT_USE_WINDOWS_TIMERS
-	LARGE_INTEGER mClockFrequency;
-	DWORD mStartTick;
-	LONGLONG mPrevElapsedTime;
-	LARGE_INTEGER mStartTime;
-#else
-#ifdef __CELLOS_LV2__
-	uint64_t	mStartTime;
-#else
-	struct timeval mStartTime;
-#endif
-#endif //__CELLOS_LV2__
-
-};
-
-///The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
-btClock::btClock()
-{
-	m_data = new btClockData;
-#ifdef BT_USE_WINDOWS_TIMERS
-	QueryPerformanceFrequency(&m_data->mClockFrequency);
-#endif
-	reset();
-}
-
-btClock::~btClock()
-{
-	delete m_data;
-}
-
-btClock::btClock(const btClock& other)
-{
-	m_data = new btClockData;
-	*m_data = *other.m_data;
-}
-
-btClock& btClock::operator=(const btClock& other)
-{
-	*m_data = *other.m_data;
-	return *this;
-}
-
-
-	/// Resets the initial reference time.
-void btClock::reset()
-{
-#ifdef BT_USE_WINDOWS_TIMERS
-	QueryPerformanceCounter(&m_data->mStartTime);
-	m_data->mStartTick = GetTickCount();
-	m_data->mPrevElapsedTime = 0;
-#else
-#ifdef __CELLOS_LV2__
-
-	typedef uint64_t  ClockSize;
-	ClockSize newTime;
-	//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
-	SYS_TIMEBASE_GET( newTime );
-	m_data->mStartTime = newTime;
-#else
-	gettimeofday(&m_data->mStartTime, 0);
-#endif
-#endif
-}
-
-/// Returns the time in ms since the last call to reset or since 
-/// the btClock was created.
-unsigned long int btClock::getTimeMilliseconds()
-{
-#ifdef BT_USE_WINDOWS_TIMERS
-	LARGE_INTEGER currentTime;
-	QueryPerformanceCounter(&currentTime);
-	LONGLONG elapsedTime = currentTime.QuadPart - 
-		m_data->mStartTime.QuadPart;
-		// Compute the number of millisecond ticks elapsed.
-	unsigned long msecTicks = (unsigned long)(1000 * elapsedTime / 
-		m_data->mClockFrequency.QuadPart);
-		// Check for unexpected leaps in the Win32 performance counter.  
-	// (This is caused by unexpected data across the PCI to ISA 
-		// bridge, aka south bridge.  See Microsoft KB274323.)
-		unsigned long elapsedTicks = GetTickCount() - m_data->mStartTick;
-		signed long msecOff = (signed long)(msecTicks - elapsedTicks);
-		if (msecOff < -100 || msecOff > 100)
-		{
-			// Adjust the starting time forwards.
-			LONGLONG msecAdjustment = mymin(msecOff * 
-				m_data->mClockFrequency.QuadPart / 1000, elapsedTime - 
-				m_data->mPrevElapsedTime);
-			m_data->mStartTime.QuadPart += msecAdjustment;
-			elapsedTime -= msecAdjustment;
-
-			// Recompute the number of millisecond ticks elapsed.
-			msecTicks = (unsigned long)(1000 * elapsedTime / 
-				m_data->mClockFrequency.QuadPart);
-		}
-
-		// Store the current elapsed time for adjustments next time.
-		m_data->mPrevElapsedTime = elapsedTime;
-
-		return msecTicks;
-#else
-
-#ifdef __CELLOS_LV2__
-		uint64_t freq=sys_time_get_timebase_frequency();
-		double dFreq=((double) freq) / 1000.0;
-		typedef uint64_t  ClockSize;
-		ClockSize newTime;
-		SYS_TIMEBASE_GET( newTime );
-		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
-
-		return (unsigned long int)((double(newTime-m_data->mStartTime)) / dFreq);
-#else
-
-		struct timeval currentTime;
-		gettimeofday(&currentTime, 0);
-		return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1000 + 
-			(currentTime.tv_usec - m_data->mStartTime.tv_usec) / 1000;
-#endif //__CELLOS_LV2__
-#endif
-}
-
-	/// Returns the time in us since the last call to reset or since 
-	/// the Clock was created.
-unsigned long int btClock::getTimeMicroseconds()
-{
-#ifdef BT_USE_WINDOWS_TIMERS
-		LARGE_INTEGER currentTime;
-		QueryPerformanceCounter(&currentTime);
-		LONGLONG elapsedTime = currentTime.QuadPart - 
-			m_data->mStartTime.QuadPart;
-
-		// Compute the number of millisecond ticks elapsed.
-		unsigned long msecTicks = (unsigned long)(1000 * elapsedTime / 
-			m_data->mClockFrequency.QuadPart);
-
-		// Check for unexpected leaps in the Win32 performance counter.  
-		// (This is caused by unexpected data across the PCI to ISA 
-		// bridge, aka south bridge.  See Microsoft KB274323.)
-		unsigned long elapsedTicks = GetTickCount() - m_data->mStartTick;
-		signed long msecOff = (signed long)(msecTicks - elapsedTicks);
-		if (msecOff < -100 || msecOff > 100)
-		{
-			// Adjust the starting time forwards.
-			LONGLONG msecAdjustment = mymin(msecOff * 
-				m_data->mClockFrequency.QuadPart / 1000, elapsedTime - 
-				m_data->mPrevElapsedTime);
-			m_data->mStartTime.QuadPart += msecAdjustment;
-			elapsedTime -= msecAdjustment;
-		}
-
-		// Store the current elapsed time for adjustments next time.
-		m_data->mPrevElapsedTime = elapsedTime;
-
-		// Convert to microseconds.
-		unsigned long usecTicks = (unsigned long)(1000000 * elapsedTime / 
-			m_data->mClockFrequency.QuadPart);
-
-		return usecTicks;
-#else
-
-#ifdef __CELLOS_LV2__
-		uint64_t freq=sys_time_get_timebase_frequency();
-		double dFreq=((double) freq)/ 1000000.0;
-		typedef uint64_t  ClockSize;
-		ClockSize newTime;
-		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
-		SYS_TIMEBASE_GET( newTime );
-
-		return (unsigned long int)((double(newTime-m_data->mStartTime)) / dFreq);
-#else
-
-		struct timeval currentTime;
-		gettimeofday(&currentTime, 0);
-		return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1000000 + 
-			(currentTime.tv_usec - m_data->mStartTime.tv_usec);
-#endif//__CELLOS_LV2__
-#endif 
-}
-
-
-
-
-
 inline void Profile_Get_Ticks(unsigned long int * ticks)
 {
 	*ticks = gProfileClock.getTimeMicroseconds();
@@ -561,5 +342,5 @@
 
 
 
+#endif //USE_BT_CLOCK
 
-#endif //BT_NO_PROFILE
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btQuickprof.h c/bullet-2.77/src/LinearMath/btQuickprof.h
--- a/bullet-2.77/src/LinearMath/btQuickprof.h	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btQuickprof.h	2018-07-16 12:04:14.000000000 +0200
@@ -18,7 +18,7 @@
 //To disable built-in profiling, please comment out next line
 //#define BT_NO_PROFILE 1
 #ifndef BT_NO_PROFILE
-#include <stdio.h>//@todo remove this, backwards compatibility
+
 #include "btScalar.h"
 #include "btAlignedAllocator.h"
 #include <new>
@@ -26,34 +26,208 @@
 
 
 
-
+//if you don't need btClock, you can comment next line
 #define USE_BT_CLOCK 1
 
 #ifdef USE_BT_CLOCK
+#ifdef __CELLOS_LV2__
+#include <sys/sys_time.h>
+#include <sys/time_util.h>
+#include <stdio.h>
+#endif
+
+#if defined (SUNOS) || defined (__SUNOS__) 
+#include <stdio.h> 
+#endif
+
+#if defined(WIN32) || defined(_WIN32)
+
+#define USE_WINDOWS_TIMERS 
+#define WIN32_LEAN_AND_MEAN 
+#define NOWINRES 
+#define NOMCX 
+#define NOIME 
+#ifdef _XBOX
+#include <Xtl.h>
+#else
+#include <windows.h>
+#endif
+#include <time.h>
+
+#else
+#include <sys/time.h>
+#endif
+
+#define mymin(a,b) (a > b ? a : b)
 
 ///The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
 class btClock
 {
 public:
-	btClock();
-
-	btClock(const btClock& other);
-	btClock& operator=(const btClock& other);
+	btClock()
+	{
+#ifdef USE_WINDOWS_TIMERS
+		QueryPerformanceFrequency(&mClockFrequency);
+#endif
+		reset();
+	}
 
-	~btClock();
+	~btClock()
+	{
+	}
 
 	/// Resets the initial reference time.
-	void reset();
+	void reset()
+	{
+#ifdef USE_WINDOWS_TIMERS
+		QueryPerformanceCounter(&mStartTime);
+		mStartTick = GetTickCount();
+		mPrevElapsedTime = 0;
+#else
+#ifdef __CELLOS_LV2__
+
+		typedef uint64_t  ClockSize;
+		ClockSize newTime;
+		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
+		SYS_TIMEBASE_GET( newTime );
+		mStartTime = newTime;
+#else
+		gettimeofday(&mStartTime, 0);
+#endif
+
+#endif
+	}
 
 	/// Returns the time in ms since the last call to reset or since 
 	/// the btClock was created.
-	unsigned long int getTimeMilliseconds();
+	unsigned long int getTimeMilliseconds()
+	{
+#ifdef USE_WINDOWS_TIMERS
+		LARGE_INTEGER currentTime;
+		QueryPerformanceCounter(&currentTime);
+		LONGLONG elapsedTime = currentTime.QuadPart - 
+			mStartTime.QuadPart;
+
+		// Compute the number of millisecond ticks elapsed.
+		unsigned long msecTicks = (unsigned long)(1000 * elapsedTime / 
+			mClockFrequency.QuadPart);
+
+		// Check for unexpected leaps in the Win32 performance counter.  
+		// (This is caused by unexpected data across the PCI to ISA 
+		// bridge, aka south bridge.  See Microsoft KB274323.)
+		unsigned long elapsedTicks = GetTickCount() - mStartTick;
+		signed long msecOff = (signed long)(msecTicks - elapsedTicks);
+		if (msecOff < -100 || msecOff > 100)
+		{
+			// Adjust the starting time forwards.
+			LONGLONG msecAdjustment = mymin(msecOff * 
+				mClockFrequency.QuadPart / 1000, elapsedTime - 
+				mPrevElapsedTime);
+			mStartTime.QuadPart += msecAdjustment;
+			elapsedTime -= msecAdjustment;
+
+			// Recompute the number of millisecond ticks elapsed.
+			msecTicks = (unsigned long)(1000 * elapsedTime / 
+				mClockFrequency.QuadPart);
+		}
+
+		// Store the current elapsed time for adjustments next time.
+		mPrevElapsedTime = elapsedTime;
+
+		return msecTicks;
+#else
+
+#ifdef __CELLOS_LV2__
+		uint64_t freq=sys_time_get_timebase_frequency();
+		double dFreq=((double) freq) / 1000.0;
+		typedef uint64_t  ClockSize;
+		ClockSize newTime;
+		SYS_TIMEBASE_GET( newTime );
+		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
+
+		return (unsigned long int)((double(newTime-mStartTime)) / dFreq);
+#else
+
+		struct timeval currentTime;
+		gettimeofday(&currentTime, 0);
+		return (currentTime.tv_sec - mStartTime.tv_sec) * 1000 + 
+			(currentTime.tv_usec - mStartTime.tv_usec) / 1000;
+#endif //__CELLOS_LV2__
+#endif
+	}
 
 	/// Returns the time in us since the last call to reset or since 
 	/// the Clock was created.
-	unsigned long int getTimeMicroseconds();
+	unsigned long int getTimeMicroseconds()
+	{
+#ifdef USE_WINDOWS_TIMERS
+		LARGE_INTEGER currentTime;
+		QueryPerformanceCounter(&currentTime);
+		LONGLONG elapsedTime = currentTime.QuadPart - 
+			mStartTime.QuadPart;
+
+		// Compute the number of millisecond ticks elapsed.
+		unsigned long msecTicks = (unsigned long)(1000 * elapsedTime / 
+			mClockFrequency.QuadPart);
+
+		// Check for unexpected leaps in the Win32 performance counter.  
+		// (This is caused by unexpected data across the PCI to ISA 
+		// bridge, aka south bridge.  See Microsoft KB274323.)
+		unsigned long elapsedTicks = GetTickCount() - mStartTick;
+		signed long msecOff = (signed long)(msecTicks - elapsedTicks);
+		if (msecOff < -100 || msecOff > 100)
+		{
+			// Adjust the starting time forwards.
+			LONGLONG msecAdjustment = mymin(msecOff * 
+				mClockFrequency.QuadPart / 1000, elapsedTime - 
+				mPrevElapsedTime);
+			mStartTime.QuadPart += msecAdjustment;
+			elapsedTime -= msecAdjustment;
+		}
+
+		// Store the current elapsed time for adjustments next time.
+		mPrevElapsedTime = elapsedTime;
+
+		// Convert to microseconds.
+		unsigned long usecTicks = (unsigned long)(1000000 * elapsedTime / 
+			mClockFrequency.QuadPart);
+
+		return usecTicks;
+#else
+
+#ifdef __CELLOS_LV2__
+		uint64_t freq=sys_time_get_timebase_frequency();
+		double dFreq=((double) freq)/ 1000000.0;
+		typedef uint64_t  ClockSize;
+		ClockSize newTime;
+		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
+		SYS_TIMEBASE_GET( newTime );
+
+		return (unsigned long int)((double(newTime-mStartTime)) / dFreq);
+#else
+
+		struct timeval currentTime;
+		gettimeofday(&currentTime, 0);
+		return (currentTime.tv_sec - mStartTime.tv_sec) * 1000000 + 
+			(currentTime.tv_usec - mStartTime.tv_usec);
+#endif//__CELLOS_LV2__
+#endif 
+	}
+
 private:
-	struct btClockData* m_data;
+#ifdef USE_WINDOWS_TIMERS
+	LARGE_INTEGER mClockFrequency;
+	DWORD mStartTick;
+	LONGLONG mPrevElapsedTime;
+	LARGE_INTEGER mStartTime;
+#else
+#ifdef __CELLOS_LV2__
+	uint64_t	mStartTime;
+#else
+	struct timeval mStartTime;
+#endif
+#endif //__CELLOS_LV2__
+
 };
 
 #endif //USE_BT_CLOCK
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btScalar.h c/bullet-2.77/src/LinearMath/btScalar.h
--- a/bullet-2.77/src/LinearMath/btScalar.h	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btScalar.h	2018-07-16 12:04:14.000000000 +0200
@@ -253,7 +253,7 @@
 	tempf = y;
 	*tfptr = (0xbfcdd90a - *tfptr)>>1; /* estimate of 1/sqrt(y) */
 	x =  tempf;
-	z =  y*btScalar(0.5);
+	z =  y*btScalar(0.5);                        /* hoist out the /2    */
 	x = (btScalar(1.5)*x)-(x*x)*(x*z);         /* iteration formula     */
 	x = (btScalar(1.5)*x)-(x*x)*(x*z);
 	x = (btScalar(1.5)*x)-(x*x)*(x*z);
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btSerializer.h c/bullet-2.77/src/LinearMath/btSerializer.h
--- a/bullet-2.77/src/LinearMath/btSerializer.h	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btSerializer.h	2018-07-16 12:30:46.000000000 +0200
@@ -4,8 +4,8 @@
 
 This software is provided 'as-is', without any express or implied warranty.
 In no event will the authors be held liable for any damages arising from the use of this software.
-Permission is granted to anyone to use this software for any purpose, 
-including commercial applications, and to alter it and redistribute it freely, 
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:
 
 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
@@ -33,12 +33,12 @@
 extern unsigned char sBulletDNAstr64[];
 extern int sBulletDNAlen64;
 
-SIMD_FORCE_INLINE	int btStrLen(const char* str) 
+SIMD_FORCE_INLINE	int btStrLen(const char* str)
 {
-    if (!str) 
+    if (!str)
 		return(0);
 	int len = 0;
-    
+
 	while (*str != 0)
 	{
         str++;
@@ -86,7 +86,7 @@
 	virtual	void*	getUniquePointer(void*oldPtr) = 0;
 
 	virtual	void	startSerialization() = 0;
-	
+
 	virtual	void	finishSerialization() = 0;
 
 	virtual	const char*	findNameForPointer(const void* ptr) const = 0;
@@ -119,8 +119,6 @@
 #define BT_TRIANLGE_INFO_MAP	MAKE_ID('T','M','A','P')
 #define BT_SHAPE_CODE			MAKE_ID('S','H','A','P')
 #define BT_ARRAY_CODE			MAKE_ID('A','R','A','Y')
-#define BT_DNA_CODE				MAKE_ID('D','N','A','1')
-
 
 
 struct	btPointerUid
@@ -143,15 +141,15 @@
 	btHashMap<btHashInt, int>			mStructReverse;
 	btHashMap<btHashString,int>	mTypeLookup;
 
-	
+
 	btHashMap<btHashPtr,void*>	m_chunkP;
-	
+
 	btHashMap<btHashPtr,const char*>	m_nameMap;
 
 	btHashMap<btHashPtr,btPointerUid>	m_uniquePointers;
 	int	m_uniqueIdGenerator;
 
-	int					m_totalSize;
+	//int					m_totalSize;
 	unsigned char*		m_buffer;
 	int					m_currentSize;
 	void*				m_dna;
@@ -161,10 +159,10 @@
 
 
 	btAlignedObjectArray<btChunk*>	m_chunkPtrs;
-	
+
 protected:
 
-	virtual	void*	findPointer(void* oldPtr) 
+	virtual	void*	findPointer(void* oldPtr)
 	{
 		void** ptr = m_chunkP.find(oldPtr);
 		if (ptr && *ptr)
@@ -172,15 +170,15 @@
 		return 0;
 	}
 
-	
+
 
 
 
 		void	writeDNA()
 		{
-			btChunk* dnaChunk = allocate(m_dnaLength,1);
-			memcpy(dnaChunk->m_oldPtr,m_dna,m_dnaLength);
-			finalizeChunk(dnaChunk,"DNA1",BT_DNA_CODE, m_dna);
+			unsigned char* dnaTarget = m_buffer+m_currentSize;
+			memcpy(dnaTarget,m_dna,m_dnaLength);
+			m_currentSize += m_dnaLength;
 		}
 
 		int getReverseType(const char *type) const
@@ -190,7 +188,7 @@
 			const int* valuePtr = mTypeLookup.find(key);
 			if (valuePtr)
 				return *valuePtr;
-			
+
 			return -1;
 		}
 
@@ -202,7 +200,7 @@
 
 			int littleEndian= 1;
 			littleEndian= ((char*)&littleEndian)[0];
-			
+
 
 			m_dna = btAlignedAlloc(dnalen,16);
 			memcpy(m_dna,bdnaOrg,dnalen);
@@ -230,16 +228,16 @@
 			// Parse names
 			if (!littleEndian)
 				*intPtr = btSwapEndian(*intPtr);
-				
+
 			dataLen = *intPtr;
-			
+
 			intPtr++;
 
 			cp = (char*)intPtr;
 			int i;
 			for ( i=0; i<dataLen; i++)
 			{
-				
+
 				while (*cp)cp++;
 				cp++;
 			}
@@ -265,11 +263,11 @@
 
 			if (!littleEndian)
 				*intPtr =  btSwapEndian(*intPtr);
-			
+
 			dataLen = *intPtr;
 			intPtr++;
 
-			
+
 			cp = (char*)intPtr;
 			for (i=0; i<dataLen; i++)
 			{
@@ -328,7 +326,7 @@
 
 			if (!littleEndian)
 				*intPtr = btSwapEndian(*intPtr);
-			dataLen = *intPtr ; 
+			dataLen = *intPtr ;
 			intPtr++;
 
 
@@ -336,7 +334,7 @@
 			for (i=0; i<dataLen; i++)
 			{
 				mStructs.push_back (shtPtr);
-				
+
 				if (!littleEndian)
 				{
 					shtPtr[0]= btSwapEndian(shtPtr[0]);
@@ -366,20 +364,20 @@
 			}
 		}
 
-public:	
-	
+public:
+
+
 
-	
 
 		btDefaultSerializer(int totalSize)
-			:m_totalSize(totalSize),
+			://m_totalSize(totalSize),
 			m_currentSize(0),
 			m_dna(0),
 			m_dnaLength(0),
 			m_serializationFlags(0)
 		{
 			m_buffer = (unsigned char*)btAlignedAlloc(totalSize, 16);
-			
+
 			const bool VOID_IS_8 = ((sizeof(void*)==8));
 
 #ifdef BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
@@ -398,7 +396,7 @@
 				btAssert(0);
 #endif
 			}
-	
+
 #else //BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
 			if (VOID_IS_8)
 			{
@@ -408,10 +406,10 @@
 				initDNA((const char*)sBulletDNAstr,sBulletDNAlen);
 			}
 #endif //BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
-	
+
 		}
 
-		virtual ~btDefaultSerializer() 
+		virtual ~btDefaultSerializer()
 		{
 			if (m_buffer)
 				btAlignedFree(m_buffer);
@@ -430,7 +428,7 @@
 #else
 			memcpy(m_buffer, "BULLETf", 7);
 #endif //BT_USE_DOUBLE_PRECISION
-	
+
 			int littleEndian= 1;
 			littleEndian= ((char*)&littleEndian)[0];
 
@@ -444,7 +442,7 @@
 
 			if (littleEndian)
 			{
-				m_buffer[8]='v';				
+				m_buffer[8]='v';
 			} else
 			{
 				m_buffer[8]='V';
@@ -453,9 +451,9 @@
 
 			m_buffer[9] = '2';
 			m_buffer[10] = '7';
-			m_buffer[11] = '7';
+			m_buffer[11] = '6';
+
 
-			
 		}
 
 		virtual	void	finishSerialization()
@@ -484,7 +482,7 @@
 				return uptr->m_ptr;
 			}
 			m_uniqueIdGenerator++;
-			
+
 			btPointerUid uid;
 			uid.m_uniqueIds[0] = m_uniqueIdGenerator;
 			uid.m_uniqueIds[1] = m_uniqueIdGenerator;
@@ -511,37 +509,37 @@
 			}
 
 			chunk->m_dna_nr = getReverseType(structType);
-			
+
 			chunk->m_chunkCode = chunkCode;
-			
+
 			void* uniquePtr = getUniquePointer(oldPtr);
-			
+
 			m_chunkP.insert(oldPtr,uniquePtr);//chunk->m_oldPtr);
 			chunk->m_oldPtr = uniquePtr;//oldPtr;
-			
+
 		}
 
-		
 
-		
+
+
 
 		virtual	btChunk*	allocate(size_t size, int numElements)
 		{
 
 			unsigned char* ptr = m_buffer+m_currentSize;
 			m_currentSize += int(size)*numElements+sizeof(btChunk);
-			btAssert(m_currentSize<m_totalSize);
+			//btAssert(m_currentSize<m_totalSize);
 
 			unsigned char* data = ptr + sizeof(btChunk);
-			
+
 			btChunk* chunk = (btChunk*)ptr;
 			chunk->m_chunkCode = 0;
 			chunk->m_oldPtr = data;
 			chunk->m_length = int(size)*numElements;
 			chunk->m_number = numElements;
-			
+
 			m_chunkPtrs.push_back(chunk);
-			
+
 
 			return chunk;
 		}
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btTransformUtil.h c/bullet-2.77/src/LinearMath/btTransformUtil.h
--- a/bullet-2.77/src/LinearMath/btTransformUtil.h	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btTransformUtil.h	2018-07-16 12:51:40.000000000 +0200
@@ -3,8 +3,8 @@
 
 This software is provided 'as-is', without any express or implied warranty.
 In no event will the authors be held liable for any damages arising from the use of this software.
-Permission is granted to anyone to use this software for any purpose, 
-including commercial applications, and to alter it and redistribute it freely, 
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:
 
 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
@@ -26,7 +26,7 @@
 {
 	return btVector3(supportDir.x() < btScalar(0.0) ? -halfExtents.x() : halfExtents.x(),
       supportDir.y() < btScalar(0.0) ? -halfExtents.y() : halfExtents.y(),
-      supportDir.z() < btScalar(0.0) ? -halfExtents.z() : halfExtents.z()); 
+      supportDir.z() < btScalar(0.0) ? -halfExtents.z() : halfExtents.z());
 }
 
 
@@ -53,7 +53,7 @@
 		//google for "Practical Parameterization of Rotations Using the Exponential Map", F. Sebastian Grassia
 
 		btVector3 axis;
-		btScalar	fAngle = angvel.length(); 
+		btScalar	fAngle = angvel.length();
 		//limit the angular motion
 		if (fAngle*timeStep > ANGULAR_MOTION_THRESHOLD)
 		{
@@ -124,9 +124,9 @@
 		btQuaternion dorn;
 		dmat.getRotation(dorn);
 
-		///floating point inaccuracy can lead to w component > 1..., which breaks 
+		///floating point inaccuracy can lead to w component > 1..., which breaks
 		dorn.normalize();
-		
+
 		angle = dorn.getAngle();
 		axis = btVector3(dorn.x(),dorn.y(),dorn.z());
 		axis[3] = btScalar(0.);
@@ -141,7 +141,7 @@
 };
 
 
-///The btConvexSeparatingDistanceUtil can help speed up convex collision detection 
+///The btConvexSeparatingDistanceUtil can help speed up convex collision detection
 ///by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
 class	btConvexSeparatingDistanceUtil
 {
@@ -149,7 +149,7 @@
 	btQuaternion	m_ornB;
 	btVector3	m_posA;
 	btVector3	m_posB;
-	
+
 	btVector3	m_separatingNormal;
 
 	btScalar	m_boundingRadiusA;
@@ -179,23 +179,23 @@
 
 		if (m_separatingDistance>0.f)
 		{
-			
+
 
 			btVector3 linVelA,angVelA,linVelB,angVelB;
 			btTransformUtil::calculateVelocityQuaternion(m_posA,toPosA,m_ornA,toOrnA,btScalar(1.),linVelA,angVelA);
 			btTransformUtil::calculateVelocityQuaternion(m_posB,toPosB,m_ornB,toOrnB,btScalar(1.),linVelB,angVelB);
 			btScalar maxAngularProjectedVelocity = angVelA.length() * m_boundingRadiusA + angVelB.length() * m_boundingRadiusB;
-			btVector3 relLinVel = (linVelB-linVelA);
-			btScalar relLinVelocLength = relLinVel.dot(m_separatingNormal);
+			//btVector3 relLinVel = (linVelB-linVelA);
+			btScalar relLinVelocLength = (linVelB-linVelA).dot(m_separatingNormal);
 			if (relLinVelocLength<0.f)
 			{
 				relLinVelocLength = 0.f;
 			}
-	
+
 			btScalar	projectedMotion = maxAngularProjectedVelocity +relLinVelocLength;
 			m_separatingDistance -= projectedMotion;
 		}
-	
+
 		m_posA = toPosA;
 		m_posB = toPosB;
 		m_ornA = toOrnA;
@@ -209,7 +209,7 @@
 		if (m_separatingDistance>0.f)
 		{
 			m_separatingNormal = separatingVector;
-			
+
 			const btVector3& toPosA = transA.getOrigin();
 			const btVector3& toPosB = transB.getOrigin();
 			btQuaternion toOrnA = transA.getRotation();
diff -u -r --strip-trailing-cr a/bullet-2.77/src/LinearMath/btVector3.h c/bullet-2.77/src/LinearMath/btVector3.h
--- a/bullet-2.77/src/LinearMath/btVector3.h	2018-07-16 11:55:33.000000000 +0200
+++ c/bullet-2.77/src/LinearMath/btVector3.h	2018-07-16 12:04:14.000000000 +0200
@@ -148,19 +148,6 @@
    * This is symantically treating the vector like a point */
 	SIMD_FORCE_INLINE btScalar distance(const btVector3& v) const;
 
-	SIMD_FORCE_INLINE btVector3& safeNormalize() 
-	{
-		btVector3 absVec = this->absolute();
-		int maxIndex = absVec.maxAxis();
-		if (absVec[maxIndex]>0)
-		{
-			*this /= absVec[maxIndex];
-			return *this /= length();
-		}
-		setValue(1,0,0);
-		return *this;
-	}
-
   /**@brief Normalize this vector 
    * x^2 + y^2 + z^2 = 1 */
 	SIMD_FORCE_INLINE btVector3& normalize() 
@@ -171,10 +158,10 @@
   /**@brief Return a normalized version of this vector */
 	SIMD_FORCE_INLINE btVector3 normalized() const;
 
-  /**@brief Return a rotated version of this vector
+  /**@brief Rotate this vector 
    * @param wAxis The axis to rotate about 
    * @param angle The angle to rotate by */
-	SIMD_FORCE_INLINE btVector3 rotate( const btVector3& wAxis, const btScalar angle ) const;
+	SIMD_FORCE_INLINE btVector3 rotate( const btVector3& wAxis, const btScalar angle );
 
   /**@brief Return the angle between this and another vector
    * @param v The other vector */
@@ -491,7 +478,7 @@
 	return *this / length();
 } 
 
-SIMD_FORCE_INLINE btVector3 btVector3::rotate( const btVector3& wAxis, const btScalar angle ) const
+SIMD_FORCE_INLINE btVector3 btVector3::rotate( const btVector3& wAxis, const btScalar angle )
 {
 	// wAxis must be a unit lenght vector
 
