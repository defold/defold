#! /usr/bin/env python

srcdir = '.'
blddir = 'build'

APPNAME='harfbuzz'
VERSION='11.3.2'

PACKAGE_DIR='package/harfbuzz-main'

import os, shutil
import waf_dynamo
import run
from waflib import Build
from BuildUtility import create_build_utility
from build_constants import TargetOS


def options(opt):
    opt.load('waf_dynamo')

def configure(conf):
    if os.environ['DYNAMO_HOME'] != conf.env.PREFIX:
        if 'PREFIX' not in os.environ:
            conf.env.PREFIX = os.environ['DYNAMO_HOME']
            print("Setting PREFIX=$DYNAMO_HOME")

    conf.load('waf_dynamo')
    conf.env.append_unique('DEFINES', 'NDEBUG')

def build(bld):
    name = '%s-%s' % (APPNAME, VERSION)
    packagedir = 'package/%s/src' % name

    build_util = create_build_utility(bld.env)
    target_os = build_util.get_target_os()

    remove_flags = {}
    remove_flags['CXXFLAGS'] = []
    remove_flags['CXXFLAGS'].append(('-Os', 1))
    remove_flags['CXXFLAGS'].append(('-O2', 1))
    remove_flags['CXXFLAGS'].append(('-O1', 1))
    remove_flags['CXXFLAGS'].append(('-O0', 1))
    remove_flags['CXXFLAGS'].append(('/O2', 1))
    remove_flags['CXXFLAGS'].append(('/O1', 1))
    remove_flags['CXXFLAGS'].append(('/Od', 1))
    remove_flags['CXXFLAGS'].append(('-std=c++11', 0))

    OPT = '/O2' if TargetOS.WINDOWS == target_os else '-O3'

    harfbuzz = bld.stlib(features = 'c cxx remove_flags',
                         remove_flags = remove_flags,
                         source    = [f'{packagedir}/harfbuzz.cc'],
                         defines   = ['HB_TINY'],
                         includes  = ['.', '..', packagedir],
                         target    = 'harfbuzz')

    harfbuzz.env.append_unique('CXXFLAGS', OPT)
    harfbuzz.install_path = None

    if bld.env.PLATFORM in ('win32', 'x86_64-win32'):
        bld.env.STLIB_ST         = 'lib%s.lib'
        bld.env.cstlib_PATTERN   = 'lib%s.lib'
        bld.env.cxxstlib_PATTERN = 'lib%s.lib'

    bld.install_files('${PREFIX}/%s/lib/%s/' % (name, bld.env.PLATFORM), bld.env.cxxstlib_PATTERN % APPNAME)
    bld.install_files('${PREFIX}/%s/include/harfbuzz' % name,
                        bld.path.ant_glob('%s/*.hh' % packagedir) + bld.path.ant_glob('%s/*.h' % packagedir),
                        relative_base=bld.path.find_dir(packagedir),
                        relative_trick=True)

    if isinstance(bld, Build.InstallContext):
        bld.add_group() # make sure the previous install step is done before we create the archive

        output_dir = '%s/%s' % (bld.env.PREFIX, name)
        pkg = bld(rule=create_package,
                  cwd=output_dir,
                  target='%s-%s.tar.gz' % (name, bld.env.PLATFORM),
                  always=True)

        target_tar = '%s-common.tar.gz' % name

        pkg = bld(rule=create_package,
                  cwd=output_dir,
                  target=target_tar,
                  always=True)

## NOTE!
## This seems a bit hacky, and it sure is. We leave a folder behind in the packages folder now,
## so when using this to build external libraries, make sure to NOT commit that folder. We can
## potentially solve it by running some sort of cleanup task after the other package tasks perhaps.
## I tried with bld.add_groups() after the package tasks, but it was not working.
def create_package(self):
    target = self.outputs[0].abspath()
    name = self.outputs[0].name

    dirs = []
    dirs_search = ['lib', 'sdk', 'share']

    # Create the common package with includes
    if target.find("-common") > 0:
        dirs_search = ['include']

    print("SELF.CWD", self.cwd)
    for x in dirs_search:
        try_path = os.path.join(self.cwd, x)
        if os.path.exists(try_path):
            dirs.append(x)

    args = ['tar', 'zcvf', os.path.normpath(target)] + dirs

    run.command(args, cwd=self.cwd)
    print("Wrote", target)

    # copy to the defold package path
    source = target
    target = os.path.normpath(os.path.join(os.environ['DYNAMO_HOME'], '..', '..', 'packages', name))
    shutil.copy2(source, target)
    print("Installed to", target)

def package(self):
    pass
